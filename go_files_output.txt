File: ./cmd/main.go
Content:
package main

import (
	tgbotapi "github.com/go-telegram-bot-api/telegram-bot-api/v5"
	"github.com/golang-migrate/migrate/v4"
	_ "github.com/golang-migrate/migrate/v4/database/mongodb"
	_ "github.com/golang-migrate/migrate/v4/source/file"
	"log"
	"time"
	"tournament-bot/internal/bot"
	"tournament-bot/internal/db"
	"tournament-bot/internal/services"
	"tournament-bot/internal/web"
)

func main() {
	// Инициализация базы данных
	db.InitDB()

	m, err := migrate.New("file://migrations", "mongodb://localhost:27017/tournament")
	if err != nil {
		log.Fatal(err)
	}
	err = m.Up()
	if err != nil && err != migrate.ErrNoChange {
		log.Fatal(err)
	}

	// Запуск веб-сервера для обработки вебхуков
	go web.StartServer(":8080")

	go deleteUnfinishedTournaments()

	// Настройка вебхука
	err = bot.SetWebhook("7012505888:AAEtQoe-AwaoNoC5OPUQaQ6jAqNHKYAKcQk", "https://ca41-46-159-186-86.ngrok-free.app/webhook")
	if err != nil {
		log.Fatalf("Error setting webhook: %v", err)
	}

	botAPI, err := tgbotapi.NewBotAPI("7012505888:AAEtQoe-AwaoNoC5OPUQaQ6jAqNHKYAKcQk")
	if err != nil {
		log.Fatal(err)
	}

	// Установка меню команд
	commands := []tgbotapi.BotCommand{
		{Command: "start", Description: "Start the bot"},
		{Command: "create_tournament", Description: "Create a new tournament (admin only)"},
		{Command: "delete_tournament", Description: "Delete an active tournament (admin only)"},
		{Command: "join", Description: "Join the current tournament"},
		{Command: "leave", Description: "Leave the current tournament"},
		{Command: "teams", Description: "Select teams for the tournament"},
		{Command: "draw", Description: "Perform team draw for the tournament"},
		{Command: "start_tournament", Description: "Start the tournament"},
		{Command: "help", Description: "Show available commands"},
		{Command: "addadmin", Description: "Add a new admin (admin only)"},
		{Command: "removeadmin", Description: "Remove an admin (admin only)"},
		{Command: "addteamcategory", Description: "Add a new team category (admin only)"},
		{Command: "removeteamcategory", Description: "Remove a team category (admin only)"},
		{Command: "tournament_info", Description: "Show tournament standings and matches"},
		{Command: "cancel", Description: "Прервать добавление матча"},
		{Command: "start_playoff", Description: "Start the playoff stage of the tournament"},
	}

	_, err = botAPI.Request(tgbotapi.NewSetMyCommands(commands...))
	if err != nil {
		log.Printf("Error setting command menu: %v", err)
	}

	// Ожидание завершения программы
	select {}
}

func deleteUnfinishedTournaments() {
	// Настройка времени запуска задачи (6:00 AM по московскому времени)
	moscowLocation, _ := time.LoadLocation("Europe/Moscow")
	startTime := time.Date(time.Now().Year(), time.Now().Month(), time.Now().Day(), 6, 0, 0, 0, moscowLocation)

	// Если текущее время уже позже 6:00 AM, переносим запуск на следующий день
	if time.Now().After(startTime) {
		startTime = startTime.AddDate(0, 0, 1)
	}

	// Вычисляем время до запуска задачи
	duration := time.Until(startTime)

	// Ждем до наступления времени запуска
	time.Sleep(duration)

	// Бесконечный цикл для ежедневного запуска задачи
	for {
		// Получаем список всех незавершенных и неактивных турниров
		inactiveTournaments, err := services.GetInactiveTournaments()
		if err != nil {
			log.Printf("Error getting inactive tournaments: %v", err)
		} else {
			// Проверяем каждый неактивный турнир
			for _, tournament := range inactiveTournaments {
				if (!tournament.SetupCompleted || !tournament.IsActive) && time.Since(tournament.CreatedAt) > 24*time.Hour {
					// Если настройка турнира не завершена или турнир неактивен, и прошло более 24 часов с момента создания, удаляем турнир
					err := services.DeleteTournament(tournament.ID)
					if err != nil {
						log.Printf("Error deleting tournament: %v", err)
					}
				}
			}
		}

		// Ждем 1 час до следующей проверки
		time.Sleep(1 * time.Hour)
	}
}

File: ./internal/web/server.go
Content:
package web

import (
	"github.com/gorilla/mux"
	"log"
	"net/http"
	"tournament-bot/internal/bot"
)

func StartServer(addr string) {
	r := mux.NewRouter()
	//r.HandleFunc("/api/tournaments", getTournaments).Methods("GET")
	//r.HandleFunc("/api/tournaments/{id}", getTournament).Methods("GET")
	//r.HandleFunc("/api/tournaments/{id}/standings", getTournamentStandings).Methods("GET")

	// Добавьте новый маршрут для обработки входящих запросов от Telegram
	r.HandleFunc("/webhook", bot.WebhookHandler).Methods("POST")

	log.Printf("Starting server on %s", addr)
	log.Fatal(http.ListenAndServe(addr, r))
}

File: ./internal/db/models.go
Content:
package db

import (
	"time"
)

type Participant struct {
	ID   string `bson:"_id"`
	Name string `bson:"name"`
}

type Tournament struct {
	ID               int               `bson:"id"`
	Name             string            `bson:"name"`
	Participants     []string          `bson:"participants"`
	MinParticipants  int               `bson:"min_participants"`
	MaxParticipants  int               `bson:"max_participants"`
	TeamCategory     string            `bson:"team_category"`
	ParticipantTeams map[string]string `bson:"participant_teams"`
	Matches          []Match           `bson:"matches"`
	Standings        []Standing        `bson:"standings"`
	IsActive         bool              `bson:"is_active"`
	SetupCompleted   bool              `bson:"setup_completed"`
	CreatedAt        time.Time         `bson:"created_at"`
	Playoff          *Playoff          `bson:"playoff,omitempty"`
}

type Playoff struct {
	CurrentStage  string  `bson:"current_stage"`
	QuarterFinals []Match `bson:"quarter_finals"`
	SemiFinals    []Match `bson:"semi_finals"`
	Final         *Match  `bson:"final"`
	Winner        string  `bson:"winner"`
}

type TeamCategory struct {
	Name  string   `bson:"name"`
	Teams []string `bson:"teams"`
}

type Match struct {
	Team1   string    `bson:"team1"`
	Team2   string    `bson:"team2"`
	Score1  int       `bson:"score1"`
	Score2  int       `bson:"score2"`
	Date    time.Time `bson:"date"`
	Counted bool      `bson:"counted"`
}

type Standing struct {
	Team            string `bson:"team"`
	Played          int    `bson:"played"`
	Won             int    `bson:"won"`
	Drawn           int    `bson:"drawn"`
	Lost            int    `bson:"lost"`
	GoalsFor        int    `bson:"goals_for"`
	GoalsAgainst    int    `bson:"goals_against"`
	GoalsDifference int    `bson:"goals_difference"`
	Points          int    `bson:"points"`
}

func (t *Tournament) HasParticipant(participantName string) bool {
	for _, p := range t.Participants {
		if p == participantName {
			return true
		}
	}
	return false
}

type Admin struct {
	UserID int64 `bson:"user_id"`
}

File: ./internal/db/db.go
Content:
package db

import (
	"context"
	"go.mongodb.org/mongo-driver/bson"
	"go.mongodb.org/mongo-driver/mongo"
	"go.mongodb.org/mongo-driver/mongo/options"
	"log"
)

var DB *mongo.Database

func InitDB() {
	mongoURI := "mongodb://localhost:27017"

	clientOptions := options.Client().ApplyURI(mongoURI)
	client, err := mongo.Connect(context.TODO(), clientOptions)
	if err != nil {
		log.Fatal(err)
	}

	err = client.Ping(context.TODO(), nil)
	if err != nil {
		log.Fatal(err)
	}

	DB = client.Database("tournament")
	log.Println("Connected to MongoDB!")
}

func AddParticipant(name string) error {
	// Добавляем участника в базу данных
	_, err := DB.Collection("participants").InsertOne(context.Background(), bson.M{"name": name})
	return err
}

func GetAllParticipants() ([]string, error) {
	// Получаем список всех участников из базы данных
	cursor, err := DB.Collection("participants").Find(context.Background(), bson.M{})
	if err != nil {
		return nil, err
	}
	defer cursor.Close(context.Background())

	var participants []string
	for cursor.Next(context.Background()) {
		var participant bson.M
		if err := cursor.Decode(&participant); err != nil {
			return nil, err
		}
		participants = append(participants, participant["name"].(string))
	}
	return participants, nil
}

func ParticipantExists(name string) (bool, error) {
	count, err := DB.Collection("participants").CountDocuments(context.Background(), bson.M{"name": name})
	if err != nil {
		return false, err
	}
	return count > 0, nil
}

func AddTeamCategory(name string, teams []string) error {
	_, err := DB.Collection("team_categories").InsertOne(context.Background(), bson.M{
		"name":  name,
		"teams": teams,
	})
	return err
}

func GetTeamCategories() ([]TeamCategory, error) {
	cursor, err := DB.Collection("team_categories").Find(context.Background(), bson.M{})
	if err != nil {
		return nil, err
	}
	defer cursor.Close(context.Background())

	var categories []TeamCategory
	for cursor.Next(context.Background()) {
		var category TeamCategory
		if err := cursor.Decode(&category); err != nil {
			return nil, err
		}
		categories = append(categories, category)
	}
	return categories, nil
}

func GetTeamCategoryByName(name string) (*TeamCategory, error) {
	var category TeamCategory
	err := DB.Collection("team_categories").FindOne(context.Background(), bson.M{"name": name}).Decode(&category)
	if err != nil {
		return nil, err
	}
	return &category, nil
}

func SetParticipantTeam(tournamentID int, participantName, team string) error {
	filter := bson.M{
		"id": tournamentID,
	}
	update := bson.M{
		"$set": bson.M{
			"participant_teams." + participantName: team,
		},
	}
	opts := options.Update().SetUpsert(true)
	_, err := DB.Collection("tournaments").UpdateOne(context.Background(), filter, update, opts)
	return err
}

func RemoveTeamCategory(name string) error {
	_, err := DB.Collection("team_categories").DeleteOne(context.Background(), bson.M{"name": name})
	return err
}

func IsAdmin(userID int64) (bool, error) {
	filter := bson.M{"user_id": userID}
	count, err := DB.Collection("admins").CountDocuments(context.Background(), filter)
	if err != nil {
		return false, err
	}
	return count > 0, nil
}

func AddAdmin(userID int64) error {
	admin := Admin{UserID: userID}
	_, err := DB.Collection("admins").InsertOne(context.Background(), admin)
	return err
}

func RemoveAdmin(userID int64) error {
	filter := bson.M{"user_id": userID}
	_, err := DB.Collection("admins").DeleteOne(context.Background(), filter)
	return err
}

File: ./internal/bot/handlers.go
Content:
package bot

import (
	"context"
	"errors"
	"fmt"
	tgbotapi "github.com/go-telegram-bot-api/telegram-bot-api/v5"
	"go.mongodb.org/mongo-driver/bson"
	"log"
	"regexp"
	"sort"
	"strconv"
	"strings"
	"tournament-bot/internal/db"
	"tournament-bot/internal/notifications"
	"tournament-bot/internal/services"
)

type TeamSelectionState struct {
	TournamentID  int
	Team1         string
	Team2         string
	Score1        int
	Score2        int
	AwaitingScore bool
}

var teamSelectionStates = make(map[int64]*TeamSelectionState)

func handleMessage(message *tgbotapi.Message) {
	if message.IsCommand() {
		switch message.Command() {
		case "add_participant":
			addParticipantHandler(message)
		case "create_tournament":
			createTournamentHandler(message)
		case "end_tournament":
			endTournament(message)
		case "delete_tournament":
			HandleDeleteTournament(message)
		case "add_team_category":
			addTeamCategoryHandler(message)
		case "add_match":
			addMatchHandler(message)
		case "addadmin":
			handleAddAdminCommand(message)
		case "removeadmin":
			handleRemoveAdminCommand(message)

		case "tournament_info":
			tournamentInfoHandler(message)
		case "deletelastmatch":
			deleteLastMatchHandler(message)

		case "start_playoff":
			startPlayoffHandler(message)
		case "cancel":
			// Проверка наличия активного состояния выбора команд для пользователя
			_, ok := teamSelectionStates[message.From.ID]
			if ok {
				// Отправка сообщения о прерывании процесса
				msg := tgbotapi.NewMessage(message.Chat.ID, "Текущий процесс добавления результата матча был прерван. Вы можете начать новый процесс с помощью команды /add_match.")
				bot.Send(msg)

				// Сброс состояния выбора команд для пользователя
				delete(teamSelectionStates, message.From.ID)
			}
		}
	} else {
		// Проверяем, есть ли активное состояние выбора команд для пользователя
		state, ok := teamSelectionStates[message.From.ID]
		if ok && state.AwaitingScore {
			// Проверяем, является ли сообщение числом (счетом)
			if _, err := strconv.Atoi(message.Text); err == nil {
				handleScoreInput(message)
			} else {
				// Отправляем сообщение о некорректном вводе
				msg := tgbotapi.NewMessage(message.Chat.ID, "Пожалуйста, введите корректный счет (целое число).")
				bot.Send(msg)
			}
		}
	}
}

func addParticipantHandler(message *tgbotapi.Message) {
	// Получаем имя и фамилию участника из аргументов команды
	participantName := strings.TrimSpace(message.CommandArguments())
	if participantName == "" {
		bot.Send(tgbotapi.NewMessage(message.Chat.ID, "Please provide a participant name and surname."))
		return
	}

	// Проверяем, что имя и фамилия состоят только из букв и пробелов
	if !isValidName(participantName) {
		bot.Send(tgbotapi.NewMessage(message.Chat.ID, "Invalid participant name. Please provide a valid name and surname."))
		return
	}

	// Проверяем, что участник еще не был добавлен
	exists, err := db.ParticipantExists(participantName)
	if err != nil {
		log.Printf("Error checking participant existence: %v", err)
		bot.Send(tgbotapi.NewMessage(message.Chat.ID, "An error occurred while checking participant existence."))
		return
	}
	if exists {
		bot.Send(tgbotapi.NewMessage(message.Chat.ID, fmt.Sprintf("Participant %s already exists.", participantName)))
		return
	}

	// Добавляем участника в базу данных
	err = db.AddParticipant(participantName)
	if err != nil {
		log.Printf("Error adding participant: %v", err)
		bot.Send(tgbotapi.NewMessage(message.Chat.ID, "An error occurred while adding the participant."))
		return
	}

	bot.Send(tgbotapi.NewMessage(message.Chat.ID, fmt.Sprintf("Participant %s has been added.", participantName)))
}

func isValidName(name string) bool {
	// Проверяем, что имя и фамилия состоят только из букв и пробелов
	return regexp.MustCompile(`^[a-zA-Zа-яА-Я\s]+$`).MatchString(name)
}

func createTournamentHandler(message *tgbotapi.Message) {
	// Проверяем, является ли пользователь администратором
	isAdmin, err := db.IsAdmin(message.From.ID)
	if err != nil {
		log.Printf("Error checking admin status: %v", err)
		msg := tgbotapi.NewMessage(message.Chat.ID, "An error occurred while checking your admin status.")
		bot.Send(msg)
		return
	}
	if !isAdmin {
		msg := tgbotapi.NewMessage(message.Chat.ID, "You don't have permission to create tournaments.")
		bot.Send(msg)
		return
	}
	// Проверка наличия активного турнира
	activeTournament, err := services.GetActiveTournament()
	if err != nil {
		log.Printf("Error getting active tournament: %v", err)
		bot.Send(tgbotapi.NewMessage(message.Chat.ID, "An error occurred while checking for active tournament."))
		return
	}

	if activeTournament != nil {
		bot.Send(tgbotapi.NewMessage(message.Chat.ID, "There is already an active tournament. Please wait for it to finish."))
		return
	}

	// Создание нового турнира
	tournament, err := services.CreateTournament()
	if err != nil {
		log.Printf("Error creating tournament: %v", err)
		bot.Send(tgbotapi.NewMessage(message.Chat.ID, "An error occurred while creating the tournament."))
		return
	}

	// Отправка сообщения с кнопками для добавления участников
	msg := tgbotapi.NewMessage(message.Chat.ID, "A new tournament has been created. Add participants:")
	msg.ReplyMarkup, _ = getParticipantsKeyboard(tournament.ID)
	_, err = bot.Send(msg)
	if err != nil {
		log.Printf("Error sending message: %v", err)
		return
	}
}

func endTournamentHandler(message *tgbotapi.Message) {
	// Получение активного турнира
	activeTournament, err := services.GetActiveTournament()
	if err != nil {
		log.Printf("Error getting active tournament: %v", err)
		bot.Send(tgbotapi.NewMessage(message.Chat.ID, "An error occurred while checking for active tournament."))
		return
	}

	if activeTournament == nil {
		bot.Send(tgbotapi.NewMessage(message.Chat.ID, "There is no active tournament to end."))
		return
	}

	// Завершение активного турнира
	err = services.EndTournament(activeTournament.ID)
	if err != nil {
		log.Printf("Error ending tournament: %v", err)
		bot.Send(tgbotapi.NewMessage(message.Chat.ID, "An error occurred while ending the tournament."))
		return
	}

	bot.Send(tgbotapi.NewMessage(message.Chat.ID, "The active tournament has been ended."))
}

func getParticipantsKeyboard(tournamentID int) (tgbotapi.InlineKeyboardMarkup, error) {
	// Получаем список всех участников из базы данных
	participants, err := db.GetAllParticipants()
	if err != nil {
		log.Printf("Error getting participants: %v", err)
		return tgbotapi.InlineKeyboardMarkup{}, err
	}

	var rows [][]tgbotapi.InlineKeyboardButton
	for _, participant := range participants {
		var label string
		tournament, err := services.GetTournament(tournamentID)
		if err == nil && tournament.HasParticipant(participant) {
			label = "✅ " + participant
		} else {
			label = participant
		}
		callbackData := fmt.Sprintf("toggle_participant_%d_%s", tournamentID, participant)
		button := tgbotapi.NewInlineKeyboardButtonData(label, callbackData)
		rows = append(rows, []tgbotapi.InlineKeyboardButton{button})
	}

	selectCategoryCallbackData := fmt.Sprintf("select_category_%d", tournamentID)
	selectCategoryButton := tgbotapi.NewInlineKeyboardButtonData("Select Category", selectCategoryCallbackData)
	rows = append(rows, []tgbotapi.InlineKeyboardButton{selectCategoryButton})

	return tgbotapi.NewInlineKeyboardMarkup(rows...), nil
}

func endTournament(message *tgbotapi.Message) {
	// Получаем идентификатор турнира из аргументов команды
	tournamentID, err := strconv.Atoi(message.CommandArguments())
	if err != nil {
		bot.Send(tgbotapi.NewMessage(message.Chat.ID, "Invalid tournament ID"))
		return
	}

	// Завершаем турнир с указанным идентификатором
	err = services.EndTournament(tournamentID)
	if err != nil {
		bot.Send(tgbotapi.NewMessage(message.Chat.ID, "Error ending tournament: "+err.Error()))
		return
	}

	bot.Send(tgbotapi.NewMessage(message.Chat.ID, "Tournament ended"))
}

func callbackHandler(callback *tgbotapi.CallbackQuery) {
	if strings.HasPrefix(callback.Data, "toggle_participant_") {
		parts := strings.Split(callback.Data, "_")
		tournamentID, err := strconv.Atoi(parts[2])
		if err != nil {
			log.Printf("Error converting tournament ID: %v", err)
			return
		}
		participantName := parts[3]

		tournament, err := services.GetTournament(tournamentID)
		if err != nil {
			log.Printf("Error getting tournament: %v", err)
			return
		}

		if tournament.IsActive {
			// Турнир уже начат, отправляем сообщение об ошибке
			msg := tgbotapi.NewMessage(callback.Message.Chat.ID, "The tournament has already started. You cannot add or remove participants anymore.")
			bot.Send(msg)
			return
		}

		err = services.ToggleParticipant(tournamentID, participantName)
		if err != nil {
			log.Printf("Error toggling participant: %v", err)
			return
		}

		// Обновляем клавиатуру с участниками
		keyboard, err := getParticipantsKeyboard(tournamentID)
		if err != nil {
			log.Printf("Error getting participants keyboard: %v", err)
			return
		}
		msg := tgbotapi.NewEditMessageReplyMarkup(callback.Message.Chat.ID, callback.Message.MessageID, keyboard)
		_, err = bot.Send(msg)
		if err != nil {
			log.Printf("Error sending message: %v", err)
			return
		}

		// Отвечаем на callback, чтобы убрать "часики" на кнопке
		bot.Request(tgbotapi.NewCallback(callback.ID, ""))
	} else if strings.HasPrefix(callback.Data, "delete_tournament_") {
		tournamentID, _ := strconv.Atoi(strings.TrimPrefix(callback.Data, "delete_tournament_"))
		err := services.DeleteTournament(tournamentID)
		if err != nil {
			log.Printf("Error deleting tournament: %v", err)
			msg := tgbotapi.NewMessage(callback.Message.Chat.ID, "Failed to delete the tournament.")
			bot.Send(msg)
		} else {
			msg := tgbotapi.NewMessage(callback.Message.Chat.ID, "Tournament deleted successfully.")
			bot.Send(msg)
		}
	} else if strings.HasPrefix(callback.Data, "select_category_") {
		// Получаем идентификатор турнира из callback.Data
		tournamentID, err := strconv.Atoi(strings.TrimPrefix(callback.Data, "select_category_"))
		if err != nil {
			log.Printf("Error converting tournament ID: %v", err)
			return
		}

		tournament, err := services.GetTournament(tournamentID)
		if err != nil {
			log.Printf("Error getting tournament: %v", err)
			return
		}

		if tournament.IsActive {
			// Турнир уже начат, отправляем сообщение об ошибке
			msg := tgbotapi.NewMessage(callback.Message.Chat.ID, "The tournament has already started. You cannot select categories anymore.")
			bot.Send(msg)
			return
		}

		// Отправляем сообщение с клавиатурой выбора категории команд
		keyboard, err := getTeamCategoriesKeyboard(tournamentID)
		if err != nil {
			log.Printf("Error getting team categories keyboard: %v", err)
			return
		}
		msg := tgbotapi.NewMessage(callback.Message.Chat.ID, "Select the team category for the tournament:")
		msg.ReplyMarkup = keyboard
		_, err = bot.Send(msg)
		if err != nil {
			log.Printf("Error sending message: %v", err)
			return
		}

		// Отвечаем на callback, чтобы убрать "часики" на кнопке
		bot.Request(tgbotapi.NewCallback(callback.ID, ""))
	} else if strings.HasPrefix(callback.Data, "category_selected_") {
		parts := strings.Split(callback.Data, "_")
		tournamentID, err := strconv.Atoi(parts[2])
		if err != nil {
			log.Printf("Error converting tournament ID: %v", err)
			return
		}
		categoryName := parts[3]

		tournament, err := services.GetTournament(tournamentID)
		if err != nil {
			log.Printf("Error getting tournament: %v", err)
			return
		}

		if tournament.IsActive {
			// Турнир уже начат, отправляем сообщение об ошибке
			msg := tgbotapi.NewMessage(callback.Message.Chat.ID, "The tournament has already started. You cannot change the category anymore.")
			bot.Send(msg)
			return
		}

		err = services.SetTournamentTeamCategory(tournamentID, categoryName)
		if err != nil {
			log.Printf("Error setting tournament team category: %v", err)
			return
		}

		// Выполняем жеребьевку команд
		drawResult, err := services.PerformTeamDraw(tournamentID)
		if err != nil {
			log.Printf("Error performing team draw: %v", err)
			return
		}

		// Запускаем турнир
		updatedTournament, err := services.StartTournament(tournamentID)
		if err != nil {
			log.Printf("Error starting tournament: %v", err)
			msg := tgbotapi.NewMessage(callback.Message.Chat.ID, err.Error())
			bot.Send(msg)
			return
		}

		// Отправляем сообщение с результатом жеребьевки и информацией о начале турнира
		msg := tgbotapi.NewMessage(callback.Message.Chat.ID, "Team draw result:\n"+drawResult+"\nThe tournament has started!")
		_, err = bot.Send(msg)
		if err != nil {
			log.Printf("Error sending message: %v", err)
			return
		}

		err = notifications.SendTournamentStartMessage(updatedTournament)
		if err != nil {
			log.Printf("Error sending tournament start message: %v", err)
		}

		// Отвечаем на callback, чтобы убрать "часики" на кнопке
		bot.Request(tgbotapi.NewCallback(callback.ID, ""))
	} else if strings.HasPrefix(callback.Data, "team_") {
		// Проверяем, был ли явно инициирован процесс добавления матча
		state, ok := teamSelectionStates[callback.From.ID]
		if !ok {
			// Если процесс добавления матча не был инициирован, игнорируем нажатие на кнопку
			return
		}
		// Обработка выбора команды
		parts := strings.Split(callback.Data, "_")
		tournamentID, _ := strconv.Atoi(parts[1])
		team := parts[2]

		// Получение текущего состояния выбора команд для пользователя
		state, ok = teamSelectionStates[callback.From.ID]
		if !ok {
			// Создание нового состояния выбора команд, если оно не существует
			state = &TeamSelectionState{
				TournamentID: tournamentID,
			}
			teamSelectionStates[callback.From.ID] = state
		}

		if state.Team1 == "" {
			// Сохранение первой выбранной команды
			state.Team1 = team

			// Отправка сообщения с запросом второй команды
			msg := tgbotapi.NewMessage(callback.Message.Chat.ID, "Выберите вторую команду:")
			tournament, _ := services.GetTournament(tournamentID)
			msg.ReplyMarkup = getTeamsKeyboard(tournament, []string{state.Team1}, false)
			bot.Send(msg)
		} else if state.Team2 == "" {
			// Проверка, что выбранная вторая команда не совпадает с первой командой
			if team != state.Team1 {
				// Сохранение второй выбранной команды
				state.Team2 = team

				// Отправка сообщения с запросом счета первой команды
				msg := tgbotapi.NewMessage(callback.Message.Chat.ID, "Введите счет первой команды:")
				bot.Send(msg)

				// Переключение состояния на ожидание ввода счета
				state.AwaitingScore = true
			} else {
				// Отправка сообщения об ошибке, если выбрана та же команда, что и первая
				msg := tgbotapi.NewMessage(callback.Message.Chat.ID, "Вы не можете выбрать ту же команду, что и первая. Выберите другую команду.")
				bot.Send(msg)
			}
		}
	} else if callback.Data == "confirm_delete_last_match" {
		// Получение идентификатора текущего активного турнира
		tournament, err := services.GetActiveTournament()
		if err != nil {
			log.Printf("Error getting active tournament: %v", err)
			bot.Request(tgbotapi.NewCallback(callback.ID, "Произошла ошибка при получении активного турнира."))
			return
		}
		if tournament == nil {
			bot.Request(tgbotapi.NewCallback(callback.ID, "В данный момент нет активного турнира."))
			return
		}

		// Удаление последнего добавленного матча
		err = services.DeleteLastMatch(tournament.ID)
		if err != nil {
			log.Printf("Error deleting last match: %v", err)
			bot.Request(tgbotapi.NewCallback(callback.ID, "Произошла ошибка при удалении последнего матча."))
			return
		}

		// Отправка сообщения об успешном удалении
		bot.Request(tgbotapi.NewCallback(callback.ID, "Последний матч был успешно удален."))
		bot.Send(tgbotapi.NewMessage(callback.Message.Chat.ID, "Последний матч был успешно удален."))
	} else if callback.Data == "cancel_delete_last_match" {
		// Отправка сообщения об отмене удаления
		bot.Request(tgbotapi.NewCallback(callback.ID, "Удаление последнего матча отменено."))
		bot.Send(tgbotapi.NewMessage(callback.Message.Chat.ID, "Удаление последнего матча отменено."))
	}
}

func getTeamCategoriesKeyboard(tournamentID int) (tgbotapi.InlineKeyboardMarkup, error) {
	// Получаем список всех категорий команд из базы данных
	categories, err := db.GetTeamCategories()
	if err != nil {
		log.Printf("Error getting team categories: %v", err)
		return tgbotapi.InlineKeyboardMarkup{}, err
	}

	var rows [][]tgbotapi.InlineKeyboardButton
	for _, category := range categories {
		callbackData := fmt.Sprintf("category_selected_%d_%s", tournamentID, category.Name)
		button := tgbotapi.NewInlineKeyboardButtonData(category.Name, callbackData)
		rows = append(rows, []tgbotapi.InlineKeyboardButton{button})
	}

	return tgbotapi.NewInlineKeyboardMarkup(rows...), nil
}

func getTeamsKeyboard(tournament *db.Tournament, selectedTeams []string, disableButtons bool) tgbotapi.InlineKeyboardMarkup {
	var rows [][]tgbotapi.InlineKeyboardButton
	for _, participant := range tournament.Participants {
		team := tournament.ParticipantTeams[participant]

		var buttonText string
		if contains(selectedTeams, team) {
			buttonText = "✅ " + team
		} else {
			buttonText = team
		}

		var callbackData string
		if disableButtons {
			callbackData = "ignore"
		} else {
			callbackData = fmt.Sprintf("team_%d_%s", tournament.ID, team)
		}

		button := tgbotapi.NewInlineKeyboardButtonData(buttonText, callbackData)
		rows = append(rows, []tgbotapi.InlineKeyboardButton{button})
	}
	return tgbotapi.NewInlineKeyboardMarkup(rows...)
}

func contains(slice []string, item string) bool {
	for _, value := range slice {
		if value == item {
			return true
		}
	}
	return false
}

func addTeamCategoryHandler(message *tgbotapi.Message) {
	args := strings.Split(message.CommandArguments(), ",")
	if len(args) < 2 {
		bot.Send(tgbotapi.NewMessage(message.Chat.ID, "Usage: /add_team_category <category_name> <team1>,<team2>,..."))
		return
	}

	categoryName := strings.TrimSpace(args[0])
	teams := make([]string, len(args)-1)
	for i, team := range args[1:] {
		teams[i] = strings.TrimSpace(team)
	}

	err := db.AddTeamCategory(categoryName, teams)
	if err != nil {
		log.Printf("Error adding team category: %v", err)
		bot.Send(tgbotapi.NewMessage(message.Chat.ID, "An error occurred while adding the team category."))
		return
	}

	bot.Send(tgbotapi.NewMessage(message.Chat.ID, "Team category added successfully."))
}

func removeTeamCategoryHandler(message *tgbotapi.Message) {
	categoryName := strings.TrimSpace(message.CommandArguments())
	if categoryName == "" {
		bot.Send(tgbotapi.NewMessage(message.Chat.ID, "Usage: /remove_team_category <category_name>"))
		return
	}

	err := db.RemoveTeamCategory(categoryName)
	if err != nil {
		log.Printf("Error removing team category: %v", err)
		bot.Send(tgbotapi.NewMessage(message.Chat.ID, "An error occurred while removing the team category."))
		return
	}

	bot.Send(tgbotapi.NewMessage(message.Chat.ID, "Team category removed successfully."))
}

func handleAddAdminCommand(message *tgbotapi.Message) {
	// Проверяем, является ли пользователь администратором
	isAdmin, err := db.IsAdmin(message.From.ID)
	if err != nil {
		log.Printf("Error checking admin status: %v", err)
		msg := tgbotapi.NewMessage(message.Chat.ID, "An error occurred while checking your admin status.")
		bot.Send(msg)
		return
	}
	if !isAdmin {
		msg := tgbotapi.NewMessage(message.Chat.ID, "You don't have permission to add admins.")
		bot.Send(msg)
		return
	}

	// Получаем идентификатор пользователя из аргументов команды
	args := strings.Split(message.CommandArguments(), " ")
	if len(args) != 1 {
		msg := tgbotapi.NewMessage(message.Chat.ID, "Usage: /addadmin <user_id>")
		bot.Send(msg)
		return
	}
	userID, err := strconv.ParseInt(args[0], 10, 64)
	if err != nil {
		msg := tgbotapi.NewMessage(message.Chat.ID, "Invalid user ID.")
		bot.Send(msg)
		return
	}

	// Добавляем пользователя в список администраторов
	err = db.AddAdmin(userID)
	if err != nil {
		log.Printf("Error adding admin: %v", err)
		msg := tgbotapi.NewMessage(message.Chat.ID, "An error occurred while adding the admin.")
		bot.Send(msg)
		return
	}

	msg := tgbotapi.NewMessage(message.Chat.ID, "Admin added successfully.")
	bot.Send(msg)
}

func handleRemoveAdminCommand(message *tgbotapi.Message) {
	// Проверяем, является ли пользователь администратором
	isAdmin, err := db.IsAdmin(message.From.ID)
	if err != nil {
		log.Printf("Error checking admin status: %v", err)
		msg := tgbotapi.NewMessage(message.Chat.ID, "An error occurred while checking your admin status.")
		bot.Send(msg)
		return
	}
	if !isAdmin {
		msg := tgbotapi.NewMessage(message.Chat.ID, "You don't have permission to remove admins.")
		bot.Send(msg)
		return
	}

	// Получаем идентификатор пользователя из аргументов команды
	args := strings.Split(message.CommandArguments(), " ")
	if len(args) != 1 {
		msg := tgbotapi.NewMessage(message.Chat.ID, "Usage: /removeadmin <user_id>")
		bot.Send(msg)
		return
	}
	userID, err := strconv.ParseInt(args[0], 10, 64)
	if err != nil {
		msg := tgbotapi.NewMessage(message.Chat.ID, "Invalid user ID.")
		bot.Send(msg)
		return
	}

	// Удаляем пользователя из списка администраторов
	err = db.RemoveAdmin(userID)
	if err != nil {
		log.Printf("Error removing admin: %v", err)
		msg := tgbotapi.NewMessage(message.Chat.ID, "An error occurred while removing the admin.")
		bot.Send(msg)
		return
	}

	msg := tgbotapi.NewMessage(message.Chat.ID, "Admin removed successfully.")
	bot.Send(msg)
}

func HandleDeleteTournament(message *tgbotapi.Message) {
	// Проверяем, является ли пользователь администратором
	isAdmin, err := db.IsAdmin(message.From.ID)
	if err != nil {
		log.Printf("Error checking admin status: %v", err)
		msg := tgbotapi.NewMessage(message.Chat.ID, "Failed to check admin status.")
		bot.Send(msg)
		return
	}
	if !isAdmin {
		msg := tgbotapi.NewMessage(message.Chat.ID, "Only admins can delete tournaments.")
		bot.Send(msg)
		return
	}

	// Получаем список активных турниров
	activeTournaments, err := services.GetActiveTournaments()
	if err != nil {
		log.Printf("Error getting active tournaments: %v", err)
		msg := tgbotapi.NewMessage(message.Chat.ID, "Failed to get active tournaments.")
		bot.Send(msg)
		return
	}

	if len(activeTournaments) == 0 {
		msg := tgbotapi.NewMessage(message.Chat.ID, "No active tournaments found.")
		bot.Send(msg)
		return
	}

	// Создаем клавиатуру с кнопками для каждого активного турнира
	keyboard := tgbotapi.NewInlineKeyboardMarkup()
	for _, tournament := range activeTournaments {
		callbackData := fmt.Sprintf("delete_tournament_%d", tournament.ID)
		button := tgbotapi.NewInlineKeyboardButtonData(tournament.Name, callbackData)
		keyboard.InlineKeyboard = append(keyboard.InlineKeyboard, []tgbotapi.InlineKeyboardButton{button})
	}

	msg := tgbotapi.NewMessage(message.Chat.ID, "Select a tournament to delete:")
	msg.ReplyMarkup = keyboard
	bot.Send(msg)
}

func addMatchHandler(message *tgbotapi.Message) {
	// Проверка прав доступа пользователя
	isAdmin, err := db.IsAdmin(message.From.ID)
	if err != nil {
		// Обработка ошибки, если она возникла
		bot.Send(tgbotapi.NewMessage(message.Chat.ID, "Произошла ошибка при проверке прав администратора."))
		return
	}

	if !isAdmin {
		bot.Send(tgbotapi.NewMessage(message.Chat.ID, "У вас нет прав для добавления результатов матчей."))
		return
	}

	_, ok := teamSelectionStates[message.From.ID]
	if ok {
		msg := tgbotapi.NewMessage(message.Chat.ID, "У вас уже есть активный процесс добавления результата матча. Пожалуйста, завершите его перед началом нового.")
		bot.Send(msg)
		return
	}

	// Получение текущего активного турнира
	tournament, err := services.GetActiveTournament()
	if err != nil {
		log.Printf("Error getting active tournament: %v", err)
		bot.Send(tgbotapi.NewMessage(message.Chat.ID, "Ошибка при получении активного турнира."))
		return
	}
	if tournament == nil {
		bot.Send(tgbotapi.NewMessage(message.Chat.ID, "В данный момент нет активного турнира."))
		return
	}

	// Проверка статуса турнира
	if !tournament.IsActive {
		bot.Send(tgbotapi.NewMessage(message.Chat.ID, "Турнир еще не начался или уже завершен. Невозможно добавить результат матча."))
		return
	}

	if tournament.Playoff != nil {
		// Турнир находится в стадии плей-офф
		teams := services.GetCurrentStageTeams(tournament)
		if len(teams) == 0 {
			bot.Send(tgbotapi.NewMessage(message.Chat.ID, "Не удалось определить команды для текущей стадии плей-офф."))
			return
		}

		// Выводим информацию о текущем матче плей-офф
		msg := tgbotapi.NewMessage(message.Chat.ID, fmt.Sprintf("Текущий матч плей-офф: %s vs %s", teams[0], teams[1]))
		bot.Send(msg)

		// Создаем новое состояние выбора команд для пользователя
		state := &TeamSelectionState{
			TournamentID:  tournament.ID,
			Team1:         teams[0],
			Team2:         teams[1],
			AwaitingScore: true,
		}
		teamSelectionStates[message.From.ID] = state

		// Запрашиваем счет первой команды
		msg = tgbotapi.NewMessage(message.Chat.ID, fmt.Sprintf("Введите счет для команды %s:", teams[0]))
		bot.Send(msg)
	} else {
		// Турнир находится в групповом этапе
		_, ok := teamSelectionStates[message.From.ID]
		if ok {
			msg := tgbotapi.NewMessage(message.Chat.ID, "У вас уже есть активный процесс добавления результата матча. Пожалуйста, завершите его перед началом нового.")
			bot.Send(msg)
			return
		}

		// Создание нового состояния выбора команд для пользователя
		state := &TeamSelectionState{
			TournamentID: tournament.ID,
		}
		teamSelectionStates[message.From.ID] = state

		// Отправка сообщения с инструкцией и клавиатурой для выбора команд
		msg := tgbotapi.NewMessage(message.Chat.ID, "Выберите первую команду:")
		msg.ReplyMarkup = getTeamsKeyboard(tournament, []string{}, false)
		bot.Send(msg)
	}
}

func handleScoreInput(message *tgbotapi.Message) {
	// Получение текущего состояния выбора команд для пользователя
	state, ok := teamSelectionStates[message.From.ID]
	if !ok {
		return
	}

	if state.AwaitingScore {
		// Извлечение введенного счета
		score, err := strconv.Atoi(message.Text)
		if err != nil || score < 0 {
			msg := tgbotapi.NewMessage(message.Chat.ID, "Неверный формат счета. Пожалуйста, введите неотрицательное целое число.")
			bot.Send(msg)
			return
		}

		if state.Score1 == 0 {
			// Сохранение счета первой команды
			state.Score1 = score

			// Отправка сообщения с запросом счета второй команды
			msg := tgbotapi.NewMessage(message.Chat.ID, fmt.Sprintf("Введите счет для команды %s:", state.Team2))
			bot.Send(msg)
		} else if state.Score2 == 0 {
			// Сохранение счета второй команды
			state.Score2 = score

			// Получение текущего активного турнира
			tournament, err := services.GetTournament(state.TournamentID)
			if err != nil {
				log.Printf("Error getting tournament: %v", err)
				msg := tgbotapi.NewMessage(message.Chat.ID, "Произошла ошибка при получении турнира.")
				bot.Send(msg)
				delete(teamSelectionStates, message.From.ID)
				return
			}

			if tournament.Playoff != nil {
				// Турнир находится в стадии плей-офф
				err = services.AddPlayoffMatch(state.TournamentID, state.Team1, state.Team2, state.Score1, state.Score2)
				if err != nil {
					log.Printf("Error adding playoff match: %v", err)
					msg := tgbotapi.NewMessage(message.Chat.ID, "Произошла ошибка при сохранении результата матча плей-офф.")
					bot.Send(msg)
				} else {
					msg := tgbotapi.NewMessage(message.Chat.ID, "Результат матча плей-офф успешно сохранен.")
					bot.Send(msg)

					// Проверяем, завершился ли плей-офф
					if tournament.Playoff.Winner != "" {
						// Плей-офф завершился, объявляем победителя
						msg := tgbotapi.NewMessage(message.Chat.ID, fmt.Sprintf("Плей-офф завершился! Победитель: %s", tournament.Playoff.Winner))
						bot.Send(msg)
					} else {
						// Плей-офф продолжается, сообщаем о следующем матче
						nextStage := getNextStage(tournament.Playoff.CurrentStage)
						teams := services.GetCurrentStageTeams(tournament)
						if len(teams) >= 2 {
							msg := tgbotapi.NewMessage(message.Chat.ID, fmt.Sprintf("Следующий матч (%s): %s vs %s", nextStage, teams[0], teams[1]))
							bot.Send(msg)
						}
					}
				}
			} else {
				// Турнир находится в групповом этапе
				// Проверка наличия уже добавленного результата матча
				existingMatch, err := getMatchResult(state.TournamentID, state.Team1, state.Team2)
				if err == nil && existingMatch != nil {
					msg := tgbotapi.NewMessage(message.Chat.ID, "Результат матча между этими командами уже был добавлен ранее.")
					bot.Send(msg)
					delete(teamSelectionStates, message.From.ID)
					return
				}

				// Добавление результата матча в групповой этап
				err = services.AddMatchResult(state.TournamentID, state.Team1, state.Team2, state.Score1, state.Score2)
				if err != nil {
					log.Printf("Error adding match result: %v", err)
					msg := tgbotapi.NewMessage(message.Chat.ID, "Произошла ошибка при сохранении результата матча.")
					bot.Send(msg)
				} else {
					msg := tgbotapi.NewMessage(message.Chat.ID, "Результат матча успешно сохранен.")
					bot.Send(msg)
				}
			}

			// Сброс состояния выбора команд
			delete(teamSelectionStates, message.From.ID)
		}
	}
}

func getNextStage(currentStage string) string {
	switch currentStage {
	case "quarter":
		return "semi"
	case "semi":
		return "final"
	default:
		return ""
	}
}

func getMatchResult(tournamentID int, team1, team2 string) (*db.Match, error) {
	filter := bson.M{
		"id": tournamentID,
		"matches": bson.M{
			"$elemMatch": bson.M{
				"team1": team1,
				"team2": team2,
			},
		},
	}

	var tournament db.Tournament
	err := db.DB.Collection("tournaments").FindOne(context.TODO(), filter).Decode(&tournament)
	if err != nil {
		return nil, err
	}

	for _, match := range tournament.Matches {
		if match.Team1 == team1 && match.Team2 == team2 {
			return &match, nil
		}
	}

	return nil, errors.New("match not found")
}

func deleteLastMatchHandler(message *tgbotapi.Message) {
	// Получение идентификатора текущего активного турнира
	tournament, err := services.GetActiveTournament()
	if err != nil {
		log.Printf("Error getting active tournament: %v", err)
		bot.Send(tgbotapi.NewMessage(message.Chat.ID, "Произошла ошибка при получении активного турнира."))
		return
	}
	if tournament == nil {
		bot.Send(tgbotapi.NewMessage(message.Chat.ID, "В данный момент нет активного турнира."))
		return
	}

	// Получение списка матчей для турнира
	matches := services.GetTournamentMatches(tournament.ID)

	if len(matches) == 0 {
		bot.Send(tgbotapi.NewMessage(message.Chat.ID, "В турнире еще нет добавленных матчей."))
		return
	}

	// Получение последнего добавленного матча
	lastMatch := matches[len(matches)-1]

	// Отправка предупреждения перед удалением
	warningMessage := fmt.Sprintf("Вы уверены, что хотите удалить последний добавленный матч?\n\nМатч: %s vs %s\nСчет: %d - %d",
		lastMatch.Team1, lastMatch.Team2, lastMatch.Score1, lastMatch.Score2)
	confirmKeyboard := tgbotapi.NewInlineKeyboardMarkup(
		tgbotapi.NewInlineKeyboardRow(
			tgbotapi.NewInlineKeyboardButtonData("Да", "confirm_delete_last_match"),
			tgbotapi.NewInlineKeyboardButtonData("Нет", "cancel_delete_last_match"),
		),
	)
	msg := tgbotapi.NewMessage(message.Chat.ID, warningMessage)
	msg.ReplyMarkup = confirmKeyboard
	bot.Send(msg)
}

func tournamentInfoHandler(message *tgbotapi.Message) {
	// Получение идентификатора текущего активного турнира
	tournament, err := services.GetActiveTournament()
	if err != nil {
		log.Printf("Error getting active tournament: %v", err)
		bot.Send(tgbotapi.NewMessage(message.Chat.ID, "Произошла ошибка при получении активного турнира."))
		return
	}
	if tournament == nil {
		bot.Send(tgbotapi.NewMessage(message.Chat.ID, "В данный момент нет активного турнира."))
		return
	}

	// Формирование сообщения с турнирной таблицей и списком матчей
	messageParts := []string{
		fmt.Sprintf("Турнирная таблица для турнира *%s*:\n", tournament.Name),
		"```",
		"Место | Команда (Игрок)      | И | В | Н | П | ЗГ | ПГ | РГ  | О",
		strings.Repeat("-", 54),
	}

	// Создание карты для хранения соответствия команд и игроков
	teamPlayerMap := make(map[string]string)
	for player, team := range tournament.ParticipantTeams {
		teamPlayerMap[team] = player
	}

	// Создание карты для хранения статистики команд
	teamStandingsMap := make(map[string]db.Standing)
	for _, standing := range tournament.Standings {
		teamStandingsMap[standing.Team] = standing
	}

	// Сортировка команд по критериям
	standings := tournament.Standings

	sort.Slice(standings, func(i, j int) bool {
		// Сравнение по количеству очков
		if standings[i].Points != standings[j].Points {
			return standings[i].Points > standings[j].Points
		}
		// Сравнение по разнице забитых и пропущенных мячей
		if standings[i].GoalsDifference != standings[j].GoalsDifference {
			return standings[i].GoalsDifference > standings[j].GoalsDifference
		}
		// Сравнение по количеству забитых мячей
		if standings[i].GoalsFor != standings[j].GoalsFor {
			return standings[i].GoalsFor > standings[j].GoalsFor
		}
		// Сравнение по количеству сыгранных матчей
		if standings[i].Played != standings[j].Played {
			return standings[i].Played > standings[j].Played
		}
		// Сравнение по результатам личных встреч
		headToHeadResult := getHeadToHeadResult(standings[i].Team, standings[j].Team, tournament.Matches)
		if headToHeadResult != 0 {
			return headToHeadResult > 0
		}
		// Сравнение по алфавиту
		return standings[i].Team < standings[j].Team
	})

	// Вывод информации о командах в турнирной таблице
	position := 1
	for _, standing := range standings {
		player, ok := teamPlayerMap[standing.Team]
		if !ok {
			continue
		}

		// Форматирование строки с информацией о команде и игроке
		teamPlayerInfo := fmt.Sprintf("%s (%s)", standing.Team, player)

		messageParts = append(messageParts, fmt.Sprintf(
			"%-5d | %-20s | %d | %d | %d | %d | %2d | %2d | %+3d | %d",
			position, teamPlayerInfo,
			standing.Played, standing.Won, standing.Drawn, standing.Lost,
			standing.GoalsFor, standing.GoalsAgainst, standing.GoalsDifference, standing.Points,
		))

		position++
	}

	messageParts = append(messageParts, "```")

	messageParts = append(messageParts, "\nСписок матчей:\n")
	if len(tournament.Matches) == 0 {
		messageParts = append(messageParts, "Пока нет сыгранных матчей.")
	} else {
		for _, match := range tournament.Matches {
			messageParts = append(messageParts, fmt.Sprintf(
				"%s %d - %d %s",
				match.Team1, match.Score1, match.Score2, match.Team2,
			))
		}
	}

	// Добавляем информацию о плей-офф
	messageParts = append(messageParts, "\nПлей-офф:\n")

	if tournament.Playoff != nil {
		// Выводим информацию о четвертьфиналах
		if len(tournament.Playoff.QuarterFinals) > 0 {
			messageParts = append(messageParts, "Четвертьфиналы:\n")
			for _, match := range tournament.Playoff.QuarterFinals {
				messageParts = append(messageParts, fmt.Sprintf(
					"%s vs %s\n",
					match.Team1, match.Team2,
				))
			}
		}

		// Выводим информацию о полуфиналах
		if len(tournament.Playoff.SemiFinals) > 0 {
			messageParts = append(messageParts, "\nПолуфиналы:\n")
			for _, match := range tournament.Playoff.SemiFinals {
				messageParts = append(messageParts, fmt.Sprintf(
					"%s vs %s\n",
					match.Team1, match.Team2,
				))
			}
		}

		// Выводим информацию о финале
		if tournament.Playoff.Final != nil {
			messageParts = append(messageParts, "\nФинал:\n")
			messageParts = append(messageParts, fmt.Sprintf(
				"%s vs %s\n",
				tournament.Playoff.Final.Team1, tournament.Playoff.Final.Team2,
			))
		}

		// Выводим информацию о победителе
		if tournament.Playoff.Winner != "" {
			messageParts = append(messageParts, fmt.Sprintf("\nПобедитель: %s\n", tournament.Playoff.Winner))
		}
	} else {
		messageParts = append(messageParts, "Плей-офф еще не начался.")
	}

	// Отправка сообщения с турнирной таблицей, списком матчей и информацией о плей-офф
	msg := tgbotapi.NewMessage(message.Chat.ID, strings.Join(messageParts, "\n"))
	msg.ParseMode = "Markdown"
	bot.Send(msg)
}

// Добавьте эту функцию для удаления клавиатуры
func removeKeyboard(chatID int64, messageID int) {
	msg := tgbotapi.NewEditMessageReplyMarkup(chatID, messageID, tgbotapi.InlineKeyboardMarkup{})
	bot.Send(msg)
}

func startPlayoffHandler(message *tgbotapi.Message) {
	// Получение идентификатора текущего активного турнира
	tournament, err := services.GetActiveTournament()
	if err != nil {
		log.Printf("Error getting active tournament: %v", err)
		bot.Send(tgbotapi.NewMessage(message.Chat.ID, "Произошла ошибка при получении активного турнира."))
		return
	}
	if tournament == nil {
		bot.Send(tgbotapi.NewMessage(message.Chat.ID, "В данный момент нет активного турнира."))
		return
	}

	// Начинаем плей-офф
	err = services.StartPlayoff(tournament.ID)
	if err != nil {
		log.Printf("Error starting playoff: %v", err)
		bot.Send(tgbotapi.NewMessage(message.Chat.ID, "Произошла ошибка при начале плей-офф."))
		return
	}

	bot.Send(tgbotapi.NewMessage(message.Chat.ID, "Плей-офф начался!"))
}

func getHeadToHeadResult(team1, team2 string, matches []db.Match) int {
	team1Wins := 0
	team2Wins := 0

	for _, match := range matches {
		if match.Team1 == team1 && match.Team2 == team2 {
			if match.Score1 > match.Score2 {
				team1Wins++
			} else if match.Score1 < match.Score2 {
				team2Wins++
			}
		} else if match.Team1 == team2 && match.Team2 == team1 {
			if match.Score1 > match.Score2 {
				team2Wins++
			} else if match.Score1 < match.Score2 {
				team1Wins++
			}
		}
	}

	if team1Wins > team2Wins {
		return 1
	} else if team1Wins < team2Wins {
		return -1
	} else {
		return 0
	}
}

File: ./internal/bot/bot.go
Content:
package bot

import (
	"encoding/json"
	"fmt"
	tgbotapi "github.com/go-telegram-bot-api/telegram-bot-api/v5"
	"net/http"
)

var bot *tgbotapi.BotAPI

func SetWebhook(token, webhookURL string) error {
	var err error
	bot, err = tgbotapi.NewBotAPI(token)
	if err != nil {
		return err
	}

	// Установка вебхука
	wh, err := tgbotapi.NewWebhook(webhookURL)
	if err != nil {
		return err
	}

	_, err = bot.Request(wh)
	if err != nil {
		return err
	}

	fmt.Println("Webhook set successfully")
	return nil
}

func WebhookHandler(w http.ResponseWriter, r *http.Request) {
	var update tgbotapi.Update
	if err := json.NewDecoder(r.Body).Decode(&update); err != nil {
		http.Error(w, err.Error(), http.StatusBadRequest)
		return
	}

	if update.Message != nil {
		handleMessage(update.Message)
	} else if update.CallbackQuery != nil {
		callbackHandler(update.CallbackQuery)
	}
}

func Send(c tgbotapi.Chattable) (tgbotapi.Message, error) {
	return bot.Send(c)
}

File: ./internal/notifications/notifications.go
Content:
package notifications

import (
	"fmt"
	tgbotapi "github.com/go-telegram-bot-api/telegram-bot-api/v5"
	"net/http"
	"strings"
	"time"
	"tournament-bot/internal/db"
)

func SendTournamentStartMessage(tournament *db.Tournament) error {
	// Формируем список участников с командами
	var participantsWithTeams []string
	for _, participant := range tournament.Participants {
		fmt.Printf("ParticipantTeams: %+v\n", tournament.ParticipantTeams)
		team := tournament.ParticipantTeams[participant]
		participantWithTeam := fmt.Sprintf("%s (%s)", participant, team)
		participantsWithTeams = append(participantsWithTeams, participantWithTeam)
	}
	participants := strings.Join(participantsWithTeams, ", ")

	// Формируем текст сообщения
	message := fmt.Sprintf("Новый турнир начался!\nНазвание: %s\nКатегория: %s\nУчастники: %s",
		tournament.Name, tournament.TeamCategory, participants)

	// Создаем MessageConfig для отправки сообщения в канал
	msg := tgbotapi.NewMessageToChannel("@test_bot_botsadfasd", message)

	// Создаем новый экземпляр бота с использованием токена
	bot, err := tgbotapi.NewBotAPI("7012505888:AAEtQoe-AwaoNoC5OPUQaQ6jAqNHKYAKcQk")
	if err != nil {
		return fmt.Errorf("failed to create bot: %v", err)
	}

	// Устанавливаем время ожидания для бота
	bot.Debug = true
	bot.Client = &http.Client{Timeout: 30 * time.Second}

	// Отправляем сообщение
	_, err = bot.Send(msg)
	if err != nil {
		return fmt.Errorf("failed to send tournament start message: %v", err)
	}

	return nil
}

File: ./internal/services/tournament.go
Content:
package services

import (
	"context"
	"errors"
	"fmt"
	"go.mongodb.org/mongo-driver/bson"
	"go.mongodb.org/mongo-driver/mongo"
	"go.mongodb.org/mongo-driver/mongo/options"
	"log"
	"math/rand/v2"
	"sort"
	"strings"
	"time"
	"tournament-bot/internal/db"
)

func GetActiveTournament() (*db.Tournament, error) {
	var tournament db.Tournament
	err := db.DB.Collection("tournaments").FindOne(context.TODO(), bson.D{{"is_active", true}}).Decode(&tournament)
	if err != nil {
		if err == mongo.ErrNoDocuments {
			return nil, nil
		}
		return nil, err
	}
	return &tournament, nil
}

func CreateTournament() (*db.Tournament, error) {
	today := time.Now().Format("2006-01-02")
	tournamentName := fmt.Sprintf("%s Tournament #%d", today, getNextTournamentNumber(today))

	tournament := &db.Tournament{
		ID:               getNextTournamentID(),
		Name:             tournamentName,
		Participants:     []string{},
		MinParticipants:  5,
		MaxParticipants:  6,
		ParticipantTeams: make(map[string]string),
		Matches:          []db.Match{},
		Standings:        []db.Standing{},
		IsActive:         false,
		SetupCompleted:   false,
		CreatedAt:        time.Now(),
	}

	_, err := db.DB.Collection("tournaments").InsertOne(context.TODO(), tournament)
	if err != nil {
		return nil, err
	}

	return tournament, nil
}

func EndTournament(tournamentID int) error {
	filter := bson.D{{"id", tournamentID}}
	update := bson.D{{"$set", bson.D{{"is_active", false}}}}
	result, err := db.DB.Collection("tournaments").UpdateOne(context.TODO(), filter, update)
	if err != nil {
		return err
	}
	if result.ModifiedCount == 0 {
		return errors.New("tournament not found or already ended")
	}
	return nil
}

func DeleteTournament(tournamentID int) error {
	filter := bson.D{{"id", tournamentID}}
	result, err := db.DB.Collection("tournaments").DeleteOne(context.TODO(), filter)
	if err != nil {
		return err
	}
	if result.DeletedCount == 0 {
		return errors.New("tournament not found")
	}
	return nil
}

func ToggleParticipant(tournamentID int, participantName string) error {
	filter := bson.M{"id": tournamentID}
	var tournament db.Tournament
	err := db.DB.Collection("tournaments").FindOne(context.TODO(), filter).Decode(&tournament)
	if err != nil {
		return err
	}

	update := bson.M{}
	if tournament.HasParticipant(participantName) {
		update["$pull"] = bson.M{"participants": participantName}
	} else {
		if len(tournament.Participants) >= tournament.MaxParticipants {
			return fmt.Errorf("tournament has reached the maximum number of participants (%d)", tournament.MaxParticipants)
		}
		update["$addToSet"] = bson.M{"participants": participantName}
	}

	_, err = db.DB.Collection("tournaments").UpdateOne(context.TODO(), filter, update)
	return err
}

func StartTournament(tournamentID int) (*db.Tournament, error) {
	filter := bson.M{"id": tournamentID}
	var tournament db.Tournament
	err := db.DB.Collection("tournaments").FindOne(context.TODO(), filter).Decode(&tournament)
	if err != nil {
		return nil, err
	}

	if len(tournament.Participants) < tournament.MinParticipants {
		return nil, fmt.Errorf("tournament requires a minimum of %d participants to start", tournament.MinParticipants)
	}

	if len(tournament.Participants) > tournament.MaxParticipants {
		return nil, fmt.Errorf("tournament exceeds the maximum limit of %d participants", tournament.MaxParticipants)
	}

	if tournament.TeamCategory == "" {
		return nil, fmt.Errorf("tournament team category is not set")
	}

	if tournament.IsActive {
		return nil, fmt.Errorf("tournament is already active")
	}

	// Проверяем условия настройки турнира
	setupCompleted := len(tournament.Participants) >= tournament.MinParticipants &&
		len(tournament.Participants) <= tournament.MaxParticipants &&
		tournament.TeamCategory != ""

	update := bson.M{
		"$set": bson.M{
			"is_active":       true,
			"setup_completed": setupCompleted,
		},
	}
	_, err = db.DB.Collection("tournaments").UpdateOne(context.TODO(), filter, update)
	if err != nil {
		return nil, err
	}

	// Получаем обновленный турнир из базы данных
	err = db.DB.Collection("tournaments").FindOne(context.TODO(), filter).Decode(&tournament)
	if err != nil {
		return nil, err
	}

	if !tournament.SetupCompleted {
		return nil, fmt.Errorf("tournament setup is not completed")
	}

	return &tournament, nil
}

func getNextTournamentID() int {
	var lastTournament db.Tournament
	opts := options.FindOne().SetSort(bson.D{{"id", -1}})
	err := db.DB.Collection("tournaments").FindOne(context.TODO(), bson.D{}, opts).Decode(&lastTournament)
	if err != nil {
		return 1
	}
	return lastTournament.ID + 1
}

func GetInactiveTournaments() ([]*db.Tournament, error) {
	filter := bson.M{"$or": []bson.M{
		{"setup_completed": false},
		{"is_active": false},
	}}
	cursor, err := db.DB.Collection("tournaments").Find(context.TODO(), filter)
	if err != nil {
		return nil, err
	}
	defer cursor.Close(context.TODO())

	var tournaments []*db.Tournament
	for cursor.Next(context.TODO()) {
		var tournament db.Tournament
		err := cursor.Decode(&tournament)
		if err != nil {
			return nil, err
		}
		tournaments = append(tournaments, &tournament)
	}

	return tournaments, nil
}

func GetTournament(tournamentID int) (*db.Tournament, error) {
	var tournament db.Tournament
	err := db.DB.Collection("tournaments").FindOne(context.TODO(), bson.M{"id": tournamentID}).Decode(&tournament)
	if err != nil {
		return nil, err
	}
	return &tournament, nil
}

func SetTournamentTeamCategory(tournamentID int, categoryName string) error {
	filter := bson.M{"id": tournamentID}
	update := bson.M{"$set": bson.M{"team_category": categoryName}}

	_, err := db.DB.Collection("tournaments").UpdateOne(context.TODO(), filter, update)
	return err
}

func PerformTeamDraw(tournamentID int) (string, error) {
	tournament, err := GetTournament(tournamentID)
	if err != nil {
		return "", err
	}

	category, err := db.GetTeamCategoryByName(tournament.TeamCategory)
	if err != nil {
		return "", err
	}

	// Перемешиваем список команд
	teams := make([]string, len(category.Teams))
	copy(teams, category.Teams)
	rand.Shuffle(len(teams), func(i, j int) {
		teams[i], teams[j] = teams[j], teams[i]
	})

	// Назначаем команды участникам турнира
	var drawResult strings.Builder
	for i, participant := range tournament.Participants {
		team := teams[i%len(teams)]
		// Сохраняем назначенную команду для участника в базе данных
		err := db.SetParticipantTeam(tournament.ID, participant, team)
		if err != nil {
			return "", err
		}
		drawResult.WriteString(fmt.Sprintf("%s - %s\n", participant, team))
	}

	// Создаем записи статистики для каждой команды с нулевыми показателями
	standings := make([]db.Standing, 0)
	for _, team := range teams {
		standing := db.Standing{
			Team:            team,
			Played:          0,
			Won:             0,
			Drawn:           0,
			Lost:            0,
			GoalsFor:        0,
			GoalsAgainst:    0,
			GoalsDifference: 0,
			Points:          0,
		}
		standings = append(standings, standing)
	}

	// Обновляем турнир в базе данных с новыми записями статистики команд
	filter := bson.M{"id": tournamentID}
	update := bson.M{"$set": bson.M{"standings": standings}}
	_, err = db.DB.Collection("tournaments").UpdateOne(context.TODO(), filter, update)
	if err != nil {
		return "", err
	}

	return drawResult.String(), nil
}

func GetActiveTournaments() ([]*db.Tournament, error) {
	filter := bson.M{"is_active": true}
	cursor, err := db.DB.Collection("tournaments").Find(context.TODO(), filter)
	if err != nil {
		return nil, err
	}
	defer cursor.Close(context.TODO())

	var tournaments []*db.Tournament
	for cursor.Next(context.TODO()) {
		var tournament db.Tournament
		err := cursor.Decode(&tournament)
		if err != nil {
			return nil, err
		}
		tournaments = append(tournaments, &tournament)
	}

	return tournaments, nil
}

func getNextTournamentNumber(date string) int {
	filter := bson.M{"date": date}
	update := bson.M{"$inc": bson.M{"count": 1}}
	opts := options.FindOneAndUpdate().SetUpsert(true).SetReturnDocument(options.After)

	var result struct {
		Count int `bson:"count"`
	}

	err := db.DB.Collection("tournament_counters").FindOneAndUpdate(context.TODO(), filter, update, opts).Decode(&result)
	if err != nil {
		log.Printf("Error getting next tournament number: %v", err)
		return 1
	}

	return result.Count
}

func AddMatchResult(tournamentID int, team1, team2 string, score1, score2 int) error {
	match := db.Match{
		Team1:  team1,
		Team2:  team2,
		Score1: score1,
		Score2: score2,
	}

	filter := bson.M{"id": tournamentID}
	update := bson.M{"$push": bson.M{"matches": match}}

	_, err := db.DB.Collection("tournaments").UpdateOne(context.TODO(), filter, update)
	if err != nil {
		return err
	}

	// Обновляем турнирную таблицу
	err = updateStandings(tournamentID)
	if err != nil {
		return err
	}

	return nil
}

func updateStandings(tournamentID int) error {
	tournament, err := GetTournament(tournamentID)
	if err != nil {
		return err
	}

	// Создаем карту для быстрого доступа к записям standings по названию команды
	standingsMap := make(map[string]*db.Standing)
	for i := range tournament.Standings {
		standingsMap[tournament.Standings[i].Team] = &tournament.Standings[i]
	}

	for i, match := range tournament.Matches {
		// Проверяем, был ли матч уже учтен при обновлении статистики
		if match.Counted {
			continue
		}

		// Обновляем статистику для каждой команды матча
		standing1 := standingsMap[match.Team1]
		standing2 := standingsMap[match.Team2]

		standing1.Played++
		standing2.Played++

		standing1.GoalsFor += match.Score1
		standing1.GoalsAgainst += match.Score2
		standing2.GoalsFor += match.Score2
		standing2.GoalsAgainst += match.Score1

		standing1.GoalsDifference = standing1.GoalsFor - standing1.GoalsAgainst
		standing2.GoalsDifference = standing2.GoalsFor - standing2.GoalsAgainst

		if match.Score1 > match.Score2 {
			standing1.Won++
			standing1.Points += 3
			standing2.Lost++
		} else if match.Score1 < match.Score2 {
			standing1.Lost++
			standing2.Won++
			standing2.Points += 3
		} else {
			standing1.Drawn++
			standing1.Points++
			standing2.Drawn++
			standing2.Points++
		}

		// Помечаем матч как учтенный

		tournament.Matches[i].Counted = true
	}

	// Сохраняем обновленные standings и matches в базе данных
	filter := bson.M{"id": tournamentID}
	update := bson.M{
		"$set": bson.M{
			"standings": tournament.Standings,
			"matches":   tournament.Matches,
		},
	}
	_, err = db.DB.Collection("tournaments").UpdateOne(context.TODO(), filter, update)
	if err != nil {
		return err
	}

	return nil
}

func DeleteLastMatch(tournamentID int) error {
	// Получение турнира из базы данных
	var tournament db.Tournament
	err := db.DB.Collection("tournaments").FindOne(context.TODO(), bson.M{"id": tournamentID}).Decode(&tournament)
	if err != nil {
		return err
	}

	// Проверка наличия матчей в турнире
	if len(tournament.Matches) == 0 {
		return errors.New("no matches found in the tournament")
	}

	// Удаление последнего матча из слайса matches
	tournament.Matches = tournament.Matches[:len(tournament.Matches)-1]

	// Обновление турнира в базе данных
	_, err = db.DB.Collection("tournaments").UpdateOne(context.TODO(), bson.M{"id": tournamentID}, bson.M{"$set": bson.M{"matches": tournament.Matches}})
	if err != nil {
		return err
	}

	return nil
}

func GetTournamentStandings(tournamentID int) []db.Standing {
	var tournament db.Tournament
	err := db.DB.Collection("tournaments").FindOne(context.TODO(), bson.M{"id": tournamentID}).Decode(&tournament)
	if err != nil {
		log.Printf("Error getting tournament standings: %v", err)
		return nil
	}
	return tournament.Standings
}

func GetTournamentMatches(tournamentID int) []db.Match {
	var tournament db.Tournament
	err := db.DB.Collection("tournaments").FindOne(context.TODO(), bson.M{"id": tournamentID}).Decode(&tournament)
	if err != nil {
		log.Printf("Error getting tournament matches: %v", err)
		return nil
	}
	return tournament.Matches
}

func UpdateTournament(tournament *db.Tournament) error {
	// Обновляем турнир в базе данных
	filter := bson.M{"id": tournament.ID}
	update := bson.M{"$set": tournament}
	_, err := db.DB.Collection("tournaments").UpdateOne(context.TODO(), filter, update)
	if err != nil {
		return err
	}

	return nil
}

func StartPlayoff(tournamentID int) error {
	// Получаем турнир из базы данных
	tournament, err := GetTournament(tournamentID)
	if err != nil {
		return err
	}

	// Проверяем, что групповой этап завершен
	if !tournament.IsActive || !tournament.SetupCompleted {
		return errors.New("group stage is not completed")
	}

	// Сортируем команды по местам в турнирной таблице
	standings := tournament.Standings
	sort.Slice(standings, func(i, j int) bool {
		// Сравнение по количеству очков
		if standings[i].Points != standings[j].Points {
			return standings[i].Points > standings[j].Points
		}
		// Сравнение по разнице забитых и пропущенных мячей
		if standings[i].GoalsDifference != standings[j].GoalsDifference {
			return standings[i].GoalsDifference > standings[j].GoalsDifference
		}
		// Сравнение по количеству забитых мячей
		if standings[i].GoalsFor != standings[j].GoalsFor {
			return standings[i].GoalsFor > standings[j].GoalsFor
		}
		// Сравнение по количеству сыгранных матчей
		if standings[i].Played != standings[j].Played {
			return standings[i].Played > standings[j].Played
		}
		// Сравнение по результатам личных встреч
		headToHeadResult := getHeadToHeadResult(standings[i].Team, standings[j].Team, tournament.Matches)
		if headToHeadResult != 0 {
			return headToHeadResult > 0
		}
		// Сравнение по алфавиту
		return standings[i].Team < standings[j].Team
	})

	// Получаем команды, занявшие соответствующие места
	var teams []string
	for i := 0; i < 4 && i < len(standings); i++ {
		teams = append(teams, standings[i].Team)
	}

	// Создаем структуру плей-офф

	playoff := &db.Playoff{
		CurrentStage: "quarter",
	}

	// Команда, занявшая первое место, выходит в финал
	if len(teams) >= 1 {
		playoff.Final = &db.Match{
			Team1: teams[0],
		}
	}

	// Команда, занявшая второе место, выходит в полуфинал
	if len(teams) >= 2 {
		playoff.SemiFinals = []db.Match{
			{Team1: teams[1]},
		}
	}

	// Команды, занявшие третье и четвертое места, играют в четвертьфинале
	if len(teams) >= 4 {
		playoff.QuarterFinals = []db.Match{
			{Team1: teams[2], Team2: teams[3]},
		}
	}

	// Сохраняем структуру плей-офф в турнире
	tournament.Playoff = playoff

	// Обновляем турнир в базе данных
	err = UpdateTournament(tournament)
	if err != nil {
		return err
	}

	return nil
}

func getHeadToHeadResult(team1, team2 string, matches []db.Match) int {
	team1Wins := 0
	team2Wins := 0

	for _, match := range matches {
		if match.Team1 == team1 && match.Team2 == team2 {
			if match.Score1 > match.Score2 {
				team1Wins++
			} else if match.Score1 < match.Score2 {
				team2Wins++
			}
		} else if match.Team1 == team2 && match.Team2 == team1 {
			if match.Score1 > match.Score2 {
				team2Wins++
			} else if match.Score1 < match.Score2 {
				team1Wins++
			}
		}
	}

	if team1Wins > team2Wins {
		return 1
	} else if team1Wins < team2Wins {
		return -1
	} else {
		return 0
	}
}

func AddPlayoffMatch(tournamentID int, team1, team2 string, score1, score2 int) error {
	// Получаем турнир из базы данных
	tournament, err := GetTournament(tournamentID)
	if err != nil {
		return err
	}

	// Проверяем, что плей-офф начался
	if tournament.Playoff == nil {
		return errors.New("playoff has not started")
	}

	// Добавляем результат матча в соответствующую стадию плей-офф

	// Обновляем текущую стадию плей-офф

	switch tournament.Playoff.CurrentStage {
	case "quarter":
		// Ищем текущий матч в четвертьфиналах
		for i, match := range tournament.Playoff.QuarterFinals {
			if match.Team1 == team1 && match.Team2 == team2 {
				// Обновляем счет матча
				tournament.Playoff.QuarterFinals[i].Score1 = score1
				tournament.Playoff.QuarterFinals[i].Score2 = score2
				tournament.Playoff.QuarterFinals[i].Counted = true

				// Проверяем, завершены ли все матчи четвертьфинала
				if allMatchesCounted(tournament.Playoff.QuarterFinals) {
					// Переходим к полуфиналам
					tournament.Playoff.CurrentStage = "semi"
					// Определяем пары команд для полуфиналов
					tournament.Playoff.SemiFinals = getNextStagePairs(tournament.Playoff.QuarterFinals)
				}
				break
			}
		}
	case "semi":
		// Ищем текущий матч в полуфиналах
		for i, match := range tournament.Playoff.SemiFinals {
			if match.Team1 == team1 && match.Team2 == team2 {
				// Обновляем счет матча
				tournament.Playoff.SemiFinals[i].Score1 = score1
				tournament.Playoff.SemiFinals[i].Score2 = score2
				tournament.Playoff.SemiFinals[i].Counted = true

				// Проверяем, завершены ли все матчи полуфинала
				if allMatchesCounted(tournament.Playoff.SemiFinals) {
					// Переходим к финалу
					tournament.Playoff.CurrentStage = "final"
					// Определяем пары команд для финала
					finalPair := getNextStagePairs(tournament.Playoff.SemiFinals)
					tournament.Playoff.Final = &finalPair[0]
				}
				break
			}
		}
	case "final":
		// Обновляем счет финального матча
		tournament.Playoff.Final.Score1 = score1
		tournament.Playoff.Final.Score2 = score2
		tournament.Playoff.Final.Counted = true

		// Определяем победителя турнира
		if score1 > score2 {
			tournament.Playoff.Winner = team1
		} else if score2 > score1 {
			tournament.Playoff.Winner = team2
		}
	}

	// Обновляем турнир в базе данных
	err = UpdateTournament(tournament)
	if err != nil {
		return err
	}

	return nil
}

func getNextStagePairs(matches []db.Match) []db.Match {
	var nextStagePairs []db.Match

	for i := 0; i < len(matches); i += 2 {
		match1 := matches[i]
		match2 := matches[i+1]

		var winner1, winner2 string
		if match1.Score1 > match1.Score2 {
			winner1 = match1.Team1
		} else {
			winner1 = match1.Team2
		}
		if match2.Score1 > match2.Score2 {
			winner2 = match2.Team1
		} else {
			winner2 = match2.Team2
		}

		nextStagePair := db.Match{
			Team1: winner1,
			Team2: winner2,
		}
		nextStagePairs = append(nextStagePairs, nextStagePair)
	}

	return nextStagePairs
}

func allMatchesCounted(matches []db.Match) bool {
	for _, match := range matches {
		if !match.Counted {
			return false
		}
	}
	return true
}

func GetCurrentStageTeams(tournament *db.Tournament) []string {
	if tournament.Playoff == nil {
		return []string{}
	}

	switch tournament.Playoff.CurrentStage {
	case "quarter":
		return getQuarterFinalTeams(tournament)
	case "semi":
		return getSemiFinalTeams(tournament)
	case "final":
		return getFinalTeams(tournament)
	default:
		return []string{}
	}
}

func getWinner(match db.Match) string {
	if match.Score1 > match.Score2 {
		return match.Team1
	} else {
		return match.Team2
	}
}

func getQuarterFinalTeams(tournament *db.Tournament) []string {
	if len(tournament.Playoff.QuarterFinals) >= 1 {
		return []string{tournament.Playoff.QuarterFinals[0].Team1, tournament.Playoff.QuarterFinals[0].Team2}
	}
	return []string{}
}

func getSemiFinalTeams(tournament *db.Tournament) []string {
	if len(tournament.Playoff.SemiFinals) >= 1 {
		return []string{tournament.Playoff.SemiFinals[0].Team1, tournament.Playoff.SemiFinals[0].Team2}
	}
	return []string{}
}

func getFinalTeams(tournament *db.Tournament) []string {
	if tournament.Playoff.Final != nil {
		return []string{tournament.Playoff.Final.Team1, tournament.Playoff.Final.Team2}
	}
	return []string{}
}

